const RequestWrapper = require('./../../shared/utils/requestWrapper')
const { getIntValue } = require('./../../shared/utils/dataHelpers')
const mongoose = require('mongoose')
const {check} = require('express-validator')
const Vulnerability = require('./../../shared/models/vulnerability')(mongoose)
const {adaptMongoosePage} = require('./../../shared/utils/pagination')

const create = new RequestWrapper(
  check('name').not().isEmpty().withMessage('Name is required')
)
  .hasId('projectId')
  .setHandler(async (req, resp) => {
    const {name, level, references} = req.body
    const mayVulnerability = await Vulnerability.findOne({$and: [{name}, {projectId: req.params.projectId}]})
    if(mayVulnerability){
      throw {code: 400, msg: 'Vulnerability already exists'}
    }
    const customVulnerability = new Vulnerability({name, level, references, isCustom: true, projectId: getIntValue(req.params.projectId)})
    await customVulnerability.save()
    resp.status(200).json(customVulnerability)
  }).wrap()

const get = new RequestWrapper()
  .hasId('projectId')
  .handlePagination()
  .setHandler(async (req, resp) => {
    const { query } = req
    const offset = getIntValue(query.offset)
    const limit = getIntValue(query.limit)
    
    const mongooseQuery = {
      $or: [
        {projectId: {$eq: getIntValue(req.params.projectId)}}, 
        {isCustom: false} 
      ]
    }
    if (query.name) {
      mongooseQuery.name = { '$regex': query.name, '$options': 'i' }
    }
    if (query.level) {
      mongooseQuery.level = { '$regex': query.level, '$options': 'i' }
    }
    const vulnerabilities = await Vulnerability.aggregate([{
      $facet: {
        paginatedResult: [
          { $match: mongooseQuery },
          { $skip: offset },
          { $limit: limit }
        ],
        totalCount: [
          { $match: mongooseQuery },
          { $count: 'totalCount' }
        ]
      }
    }])
    resp.status(200).json(adaptMongoosePage(vulnerabilities))
  }).wrap()

module.exports = { create, get }