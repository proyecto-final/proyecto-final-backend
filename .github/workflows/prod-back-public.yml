name: Sherlock_BE_PROD
on:
  push:
    branches:
      - master
      - chore/sc-491/automatizar-pipelines
env:
  AWS_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
  AWS_REPOSITORY: ${{ secrets.AWS_DEFAULT_ECR }}
  AWS_ECR_REPOSITORY_URI: ${{ secrets.AWS_DEFAULT_URI_ECR}}
  MONGO_CONNECTION:  ${{secrets.MONGO_DB_CONNECTION_STRING}}
  MYSQL_CONNECTION: ${{secrets.MYSQL_CONNECTION_STRING}}
  FIRST_TASK_DEFINITION:  ${{secrets.AWS_DEFAULT_FIRST_TASK}}
  SECOND_TASK_DEFINITION:  ${{secrets.AWS_DEFAULT_SECOND_TASK}}
  THIRD_TASK_DEFINITION:  ${{secrets.AWS_DEFAULT_THIRD_TASK}}
  FOURTH_TASK_DEFINITION:  ${{secrets.AWS_DEFAULT_FOURTH_TASK}}
  CLUSTER_NAME: ${{secrets.AWS_DEFAULT_ECS_CLUSTER}}
  FIRST_SERVICE_NAME: ${{secrets.AWS_DEFAULT_ECS_FIRST_SERVICE}}
  SECOND_SERVICE_NAME: ${{secrets.AWS_DEFAULT_ECS_SECOND_SERVICE}}
  THIRD_SERVICE_NAME: ${{secrets.AWS_DEFAULT_ECS_THIRD_SERVICE}}
  FOURTH_SERVICE_NAME: ${{secrets.AWS_DEFAULT_ECS_FOURTH_SERVICE}}
  CORRELATION_URI: ${{secrets.CORRELATION_URI}}
  VPC_AWS: ${{secrets.VPC_AWS}}
  SUBNET_AWS: ${{secrets.SUBNET_AWS}}
  KEY_PAIR_AWS: ${{secrets.KEY_PAIR_AWS}}
  INSTANCE_TYPE_AWS: ${{secrets.INSTANCE_TYPE_AWS}}
  INSTANCE_STRATEGY_AWS: ${{secrets.INSTANCE_STRATEGY_AWS}}
  SECURITY_GROUP_ID: ${{secrets.SECURITY_GROUP_ID}}
  CORRELATION_API_KEY: ${{secrets.CORRELATION_API_KEY}}
  AG_ID: ${{secrets.API_GATEWAY_ID}}
 
jobs:
  create-cluster:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1
      - name: Set credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - uses: actions/checkout@master
      - uses: marocchino/setup-ecs-cli@v1
        with:
          version: "v1.18.0"
      - name: Generating resources
        id: create-cluster-and-services
        run: |
          ecs-cli up --cluster $CLUSTER_NAME --instance-type $INSTANCE_TYPE_AWS --capability-iam --size 4 --vpc $VPC_AWS --subnets $SUBNET_AWS --force --keypair $KEY_PAIR_AWS --security-group $SECURITY_GROUP_ID
          aws ecs create-service --cluster $CLUSTER_NAME --service-name $SECOND_SERVICE_NAME --task-definition $SECOND_TASK_DEFINITION --desired-count 1 --launch-type EC2 --scheduling-strategy $INSTANCE_STRATEGY_AWS --deployment-configuration maximumPercent=100,minimumHealthyPercent=0
          aws ecs create-service --cluster $CLUSTER_NAME --service-name $FIRST_SERVICE_NAME --task-definition $FIRST_TASK_DEFINITION --desired-count 1 --launch-type EC2 --scheduling-strategy $INSTANCE_STRATEGY_AWS --deployment-configuration maximumPercent=100,minimumHealthyPercent=0
          aws ecs create-service --cluster $CLUSTER_NAME --service-name $THIRD_SERVICE_NAME --task-definition $THIRD_TASK_DEFINITION --desired-count 1 --launch-type EC2 --scheduling-strategy $INSTANCE_STRATEGY_AWS --deployment-configuration maximumPercent=100,minimumHealthyPercent=0
          aws ecs create-service --cluster $CLUSTER_NAME --service-name $FOURTH_SERVICE_NAME --task-definition $FOURTH_TASK_DEFINITION --desired-count 1 --launch-type EC2 --scheduling-strategy $INSTANCE_STRATEGY_AWS --deployment-configuration maximumPercent=100,minimumHealthyPercent=0

  #### USER AND TIMELINE DEPLOY
  deploy-user-timeline:
    needs: create-cluster
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Set credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: actions/checkout@master
    - name: Deploy to prod (user module)
      id: build-image-user
      run: |
        mkdir usuarios/temp
        cp -r shared usuarios/temp/shared
        aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY_URI
        docker build --build-arg ENVIRONMENT=PROD --build-arg MYSQL_CONNECTION_STRING=${{env.MYSQL_CONNECTION}} -t $AWS_REPOSITORY:usuarios usuarios
        docker tag $AWS_REPOSITORY:usuarios $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:usuarios
        docker push $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:usuarios
    - name: Deploy to prod (timeline module)
      id: build-image-timeline
      run: |
          mkdir timeline/temp
          cp -r shared timeline/temp/shared
          aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY_URI
          docker build --build-arg MONGODB_URI=${{env.MONGO_CONNECTION}} -t $AWS_REPOSITORY:timeline timeline
          docker tag $AWS_REPOSITORY:timeline $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:timeline
          docker push $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:timeline
    - name: Download task definition
      id: get-first-task-definition
      run: |
        aws ecs describe-task-definition --task-definition $FIRST_TASK_DEFINITION --query taskDefinition > task-definition-user-timeline.json
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ./task-definition-user-timeline.json
        service: ${{ env.FIRST_SERVICE_NAME }} 
        cluster:  ${{ env.CLUSTER_NAME }}
        wait-for-service-stability: true
        
  #### CORELATION DEPLOY
  deploy-correlation:
    needs: create-cluster
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Set credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: actions/checkout@master
    - name: Deploy to prod (correlation module)
      id: build-image-correlation
      run: |
        mkdir correlacion/temp
        cp -r shared correlacion/temp/shared
        aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY_URI
        docker build --build-arg MONGODB_URI=${{env.MONGO_CONNECTION}} -t $AWS_REPOSITORY:correlacion correlacion
        docker tag $AWS_REPOSITORY:correlacion $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:correlacion
        docker push $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:correlacion
        echo "::set-output name=image::$AWS_ECR_REPOSITORY_URI:correlacion"
    - name: Download task definition
      id: get-second-task-definition
      run: |
        aws ecs describe-task-definition --task-definition $SECOND_TASK_DEFINITION --query taskDefinition > task-definition-correlation.json
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ./task-definition-correlation.json
        service: ${{ env.SECOND_SERVICE_NAME }} 
        cluster:  ${{ env.CLUSTER_NAME }}
        wait-for-service-stability: true

  #### IPS DEPLOY
  deploy-ips:
    needs: create-cluster
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Set credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: actions/checkout@master
    - name: Deploy to prod (ips module)
      id: build-image-ips
      run: |
        mkdir ips/temp
        cp -r shared ips/temp/shared
        aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY_URI
        docker build --build-arg MONGODB_URI=${{env.MONGO_CONNECTION}} -t $AWS_REPOSITORY:ips ips
        docker tag $AWS_REPOSITORY:ips $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:ips
        docker push $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:ips
    - name: Download task definition
      id: get-third-task-definition
      run: |
        aws ecs describe-task-definition --task-definition $THIRD_TASK_DEFINITION --query taskDefinition > task-definition-search-ips.json
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ./task-definition-search-ips.json
        service: ${{ env.THIRD_SERVICE_NAME }} 
        cluster:  ${{ env.CLUSTER_NAME }}
        wait-for-service-stability: true

    #### EVTX DEPLOY
  deploy-evtx:
    needs: create-cluster
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Set credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: actions/checkout@master
    - name: Deploy to prod (evtx converter module)
      id: build-image-evtx-converter
      run: |
        mkdir evtx-converter/temp
        cp -r shared evtx-converter/temp/shared
        aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY_URI
        docker build --build-arg CORRELATION_URI=${{env.CORRELATION_URI}} --build-arg API_KEY=${{env.CORRELATION_API_KEY}} -t $AWS_REPOSITORY:evtx-converter evtx-converter
        docker tag $AWS_REPOSITORY:evtx-converter $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:evtx-converter
        docker push $AWS_ECR_REPOSITORY_URI/$AWS_REPOSITORY:evtx-converter
        echo "::set-output name=image::$AWS_ECR_REPOSITORY_URI:evtx-converter"
    - name: Download task definition
      id: get-fourth-task-definition
      run: |
        aws ecs describe-task-definition --task-definition $FOURTH_TASK_DEFINITION --query taskDefinition > task-definition-search-ips.json
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ./task-definition-search-ips.json
        service: ${{ env.FOURTH_SERVICE_NAME }} 
        cluster:  ${{ env.CLUSTER_NAME }}
        wait-for-service-stability: true
  deploy-gateway:
    needs: [deploy-correlation, deploy-evtx, deploy-ips, deploy-user-timeline]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Set credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: actions/checkout@master
    - uses: marocchino/setup-ecs-cli@v1
      with:
        version: "v1.18.0"
    - name: Deploy to prod (evtx converter module)
      id: build-image-evtx-converter
      run: |
        USER_IP=$(ecs-cli ps --cluster $CLUSTER_NAME --desired-status RUNNING | grep -i -o "[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*:3030")
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id sfex21 --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$USER_IP/api/organization"
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id a7pm1i --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$USER_IP/api/organization/{proxy}" --request-parameters '{\"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id jvkcrn --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$USER_IP/api/user"
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id v2bm0o --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$USER_IP/api/user/{proxy}" --request-parameters '{\"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        TIMELINE_IP=$(ecs-cli ps --cluster sherlock --desired-status RUNNING | grep -i -o "[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*:3034")
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id ubdr93 --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$TIMELINE_IP/api/project/{projectId}/timeline" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id y4560p --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$TIMELINE_IP/api/project/{projectId}/timeline/{proxy}"  --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\" , \"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        IPS_IP=$(ecs-cli ps --cluster $CLUSTER_NAME --desired-status RUNNING | grep -i -o "[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*:3031")
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id vey6a8 --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$IPS_IP/api/project/{projectId}/ip-analysis" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id f158z7 --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$IPS_IP/api/project/{projectId}/ip-analysis/{proxy}" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\" , \"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        CORRELATION_IP=$(ecs-cli ps --cluster $CLUSTER_NAME --desired-status RUNNING | grep -i -o "[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*:3032")
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id 5d879s --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$CORRELATION_IP/api/{proxy}" --request-parameters '{\"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id whole3 --http-method GET --integration-http-method GET --type HTTP_PROXY --uri "http://$CORRELATION_IP/api/project/{projectId}/correlate/log" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id a81yvh --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$CORRELATION_IP/api/project/{projectId}/correlate/log/{proxy}" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\" , \"integration.request.path.proxy\":\"method.request.path.proxy\"}'
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id etiom6 --http-method ANY --integration-http-method ANY --type HTTP_PROXY --uri "http://$CORRELATION_IP/api/project/{projectId}/correlate/vulnerability" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\"}'
        EVTX_CONVERT_IP=$(ecs-cli ps --cluster $CLUSTER_NAME --desired-status RUNNING | grep -i -o "[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*:3036")
        aws apigateway put-integration --rest-api-id $AG_ID --resource-id whole3 --http-method POST --integration-http-method POST --type HTTP_PROXY --uri "http://$EVTX_CONVERT_IP/api/project/{projectId}/correlate/log" --request-parameters '{\"integration.request.path.projectId\":\"method.request.path.projectId\"}'
        LAMBDA_IP=$(echo $USER_IP | cut -d':' -f1) 
        aws lambda update-function-configuration --function-name lambdaAuthSherlock --environment Variables={VALIDATOR_HOST=$LAMBDA_IP}
